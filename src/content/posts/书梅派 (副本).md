---
title: åŸºäºæ ‘è“æ´¾çš„ç§»åŠ¨æ“ä½œæœºå™¨äºº
published: 2025-12-15
description: ç§»åŠ¨æ“ä½œæœºå™¨äººçš„æ§åˆ¶é€»è¾‘ä»¥åŠè§†è§‰æ‹“å±•ç›¸å…³
pinned: true
tags: ["Robot", "Raspberri Pi"]
category: "Technology"
draft: false
---
# åŸºäºæ ‘è“æ´¾çš„è§†è§‰å¼•å¯¼ç§»åŠ¨æ“ä½œæœºå™¨äººï¼šæ„å»ºä¸æ§åˆ¶é€»è¾‘

## æ‘˜è¦
æœ¬æ–‡ä»‹ç»äº†ä¸€ç§åŸºäºæ ‘è“æ´¾çš„è§†è§‰å¼•å¯¼ç§»åŠ¨æ“ä½œæœºå™¨äººç³»ç»Ÿçš„å®Œæ•´æ„å»ºæ–¹æ¡ˆã€‚ç³»ç»Ÿæ•´åˆäº†æ ‘è“æ´¾4Bä½œä¸ºä¸»æ§åˆ¶å™¨ï¼ŒOpenCVè®¡ç®—æœºè§†è§‰æ¨¡å—ï¼Œæœºæ¢°è‡‚ä¸ç§»åŠ¨åº•ç›˜ï¼Œå®ç°äº†ç›®æ ‡è¯†åˆ«ã€å®šä½æŠ“å–å’Œè‡ªä¸»ç§»åŠ¨çš„é—­ç¯æ§åˆ¶ã€‚æœ¬æ–‡è¯¦ç»†é˜è¿°äº†ç¡¬ä»¶é€‰å‹ã€è½¯ä»¶æ¶æ„ã€è§†è§‰å¤„ç†ç®—æ³•ã€è¿åŠ¨æ§åˆ¶é€»è¾‘ä»¥åŠç³»ç»Ÿé›†æˆæ–¹æ³•ã€‚

**å…³é”®è¯**ï¼šæ ‘è“æ´¾ï¼›è®¡ç®—æœºè§†è§‰ï¼›æœºæ¢°è‡‚æ§åˆ¶ï¼›ç§»åŠ¨æœºå™¨äººï¼›ROSï¼›OpenCV

---

## 1. å¼•è¨€
éšç€åµŒå…¥å¼è®¡ç®—èƒ½åŠ›çš„æå‡å’Œå¼€æºç¡¬ä»¶ç”Ÿæ€çš„æˆç†Ÿï¼Œæ„å»ºåŠŸèƒ½å¤æ‚çš„æ™ºèƒ½æœºå™¨äººç³»ç»Ÿå·²æˆä¸ºåˆ›å®¢å’Œç ”ç©¶äººå‘˜å¯è¡Œçš„ç›®æ ‡ã€‚æ ‘è“æ´¾ä»¥å…¶å‡ºè‰²çš„æ€§ä»·æ¯”ã€å®Œå–„çš„GPIOæ¥å£å’Œæ´»è·ƒçš„ç¤¾åŒºæ”¯æŒï¼Œæˆä¸ºæœºå™¨äººå¼€å‘çš„é¦–é€‰å¹³å°ä¹‹ä¸€ã€‚

æœ¬æ–‡æ‰€è¿°é¡¹ç›®æ—¨åœ¨æ„å»ºä¸€ä¸ªèƒ½å¤Ÿé€šè¿‡è§†è§‰è¯†åˆ«ç›®æ ‡ç‰©ä½“ï¼Œè‡ªä¸»å¯¼èˆªè‡³ç›®æ ‡ä½ç½®ï¼Œå¹¶æ“ä½œæœºæ¢°æ‰‹å®ŒæˆæŠ“å–ä»»åŠ¡çš„ç§»åŠ¨æœºå™¨äººã€‚è¯¥ç³»ç»Ÿç»¼åˆä½“ç°äº†æ„ŸçŸ¥ã€å†³ç­–ä¸æ‰§è¡Œä¸‰ä¸ªæ ¸å¿ƒæœºå™¨äººæŠ€æœ¯æ¨¡å—ï¼Œå…·æœ‰è¾ƒé«˜çš„æ•™å­¦ä¸ç ”ç©¶ä»·å€¼ã€‚


## 2. ç³»ç»Ÿçº¿ç¨‹æ¶æ„

```mermaid
flowchart TD
    A[ä¸»çº¿ç¨‹<br>ç³»ç»Ÿå…¥å£ä¸åˆå§‹åŒ–] --> B[ä¸­å¤®æ§åˆ¶å™¨<br>åè°ƒä¸ç›‘æ§]
    B --> C[æ§åˆ¶çº¿ç¨‹<br>50Hz<br>çŠ¶æ€æœº/è¿åŠ¨æ§åˆ¶/æœºæ¢°è‡‚]
    B --> D[è§†è§‰çº¿ç¨‹<br>20Hz<br>å›¾åƒé‡‡é›†/ç›®æ ‡è¯†åˆ«/åæ ‡è½¬æ¢]
    B --> E[ä¼ æ„Ÿå™¨çº¿ç¨‹<br>10Hz<br>è¶…å£°æ³¢/IMU/ç¼–ç å™¨/æŒ‰é’®]
    B --> F[UIçº¿ç¨‹<br>5Hz<br>çŠ¶æ€æ˜¾ç¤º/æ—¥å¿—è®°å½•/LEDæ§åˆ¶]
    C & D & E & F --> G[å…±äº«æ•°æ®åŒº<br>ç›®æ ‡é˜Ÿåˆ—/å‘½ä»¤é˜Ÿåˆ—/çŠ¶æ€å˜é‡]
    G --> C
    G --> F
```

### 2.1 çº¿ç¨‹åŠŸèƒ½è¯¦è¡¨

| çº¿ç¨‹åç§° | æ‰§è¡Œé¢‘ç‡ | ä¸»è¦åŠŸèƒ½ | ä¼˜å…ˆçº§ | ä¾èµ–å…³ç³» |
|---------|----------|----------|--------|----------|
| **ä¸»çº¿ç¨‹** | ä¸€æ¬¡æ€§ | ç³»ç»Ÿåˆå§‹åŒ–ã€å¯åŠ¨æ‰€æœ‰çº¿ç¨‹ã€ç”¨æˆ·å‘½ä»¤å¤„ç† | - | æ—  |
| **ä¸­å¤®æ§åˆ¶å™¨** | æŒç»­è¿è¡Œ | çº¿ç¨‹åè°ƒã€çŠ¶æ€ç›‘æ§ã€èµ„æºç®¡ç† | - | æ‰€æœ‰çº¿ç¨‹ |
| **æ§åˆ¶çº¿ç¨‹** | 50Hz (20ms) | çŠ¶æ€æœºå¤„ç†ã€è¿åŠ¨æ§åˆ¶ã€æœºæ¢°è‡‚æ§åˆ¶ã€ä»»åŠ¡æ‰§è¡Œ | æœ€é«˜ | è§†è§‰çº¿ç¨‹ã€ä¼ æ„Ÿå™¨çº¿ç¨‹ |
| **è§†è§‰çº¿ç¨‹** | 20Hz (50ms) | å›¾åƒé‡‡é›†ã€ç›®æ ‡è¯†åˆ«ã€åæ ‡è®¡ç®—ã€æ•°æ®æ»¤æ³¢ | é«˜ | æ—  |
| **ä¼ æ„Ÿå™¨çº¿ç¨‹** | 10Hz (100ms) | è¶…å£°æ³¢æµ‹è·ã€IMUæ•°æ®ã€ç¼–ç å™¨è¯»å–ã€æŒ‰é’®æ£€æµ‹ | ä¸­ | æ—  |
| **UI/çŠ¶æ€çº¿ç¨‹** | 5Hz (200ms) | çŠ¶æ€æ˜¾ç¤ºã€æ—¥å¿—è®°å½•ã€LEDæ§åˆ¶ã€ç”¨æˆ·äº¤äº’ | ä½ | æ‰€æœ‰çº¿ç¨‹ |
| **å…±äº«æ•°æ®åŒº** | å®æ—¶è®¿é—® | ç›®æ ‡é˜Ÿåˆ—ã€å‘½ä»¤é˜Ÿåˆ—ã€çŠ¶æ€å˜é‡åŒæ­¥ | - | æ‰€æœ‰çº¿ç¨‹ |

### 2.2 çº¿ç¨‹é—´é€šä¿¡

```mermaid
flowchart LR
    A[è§†è§‰çº¿ç¨‹] -->|ç›®æ ‡ä¿¡æ¯| B[ç›®æ ‡é˜Ÿåˆ—]
    B -->|ç›®æ ‡æ•°æ®| C[æ§åˆ¶çº¿ç¨‹]
    
    D[UIçº¿ç¨‹] -->|æ§åˆ¶å‘½ä»¤| E[å‘½ä»¤é˜Ÿåˆ—]
    E -->|æ‰§è¡ŒæŒ‡ä»¤| C
    
    F[ä¼ æ„Ÿå™¨çº¿ç¨‹] -->|ä¼ æ„Ÿå™¨æ•°æ®| G[çŠ¶æ€å˜é‡]
    G -->|çŠ¶æ€æ›´æ–°| H[æ‰€æœ‰çº¿ç¨‹]
    
    C -->|æ‰§è¡ŒçŠ¶æ€| E
    C -->|ç³»ç»ŸçŠ¶æ€| G
```





### 2.3 çº¿ç¨‹å¯åŠ¨é¡ºåº

```mermaid
flowchart TD
    A[ä¸»çº¿ç¨‹å¯åŠ¨] --> B[ç³»ç»Ÿåˆå§‹åŒ–]
    B --> C[åˆ›å»ºä¸­å¤®æ§åˆ¶å™¨]
    C --> D[åˆ›å»ºå…±äº«æ•°æ®åŒº]
    D --> E[å¯åŠ¨æ§åˆ¶çº¿ç¨‹]
    E --> F[å¯åŠ¨è§†è§‰çº¿ç¨‹]
    F --> G[å¯åŠ¨ä¼ æ„Ÿå™¨çº¿ç¨‹]
    G --> H[å¯åŠ¨UIçº¿ç¨‹]
    H --> I[æ‰€æœ‰çº¿ç¨‹è¿è¡Œä¸­]
    I --> J[ç­‰å¾…ç³»ç»Ÿç»“æŸ]
    J --> K[æ¸…ç†èµ„æºé€€å‡º]
```

### 2.4 å…³é”®ç‰¹æ€§è¯´æ˜

1. **å¤šçº¿ç¨‹å¹¶è¡Œ**ï¼šå››ä¸ªå·¥ä½œçº¿ç¨‹ç‹¬ç«‹è¿è¡Œï¼Œæé«˜ç³»ç»Ÿå“åº”é€Ÿåº¦
2. **ä¼˜å…ˆçº§åˆ†å±‚**ï¼šæ§åˆ¶çº¿ç¨‹ä¼˜å…ˆçº§æœ€é«˜ï¼Œç¡®ä¿å®æ—¶æ€§
3. **æ•°æ®å…±äº«**ï¼šé€šè¿‡å…±äº«æ•°æ®åŒºå®‰å…¨äº¤æ¢ä¿¡æ¯
4. **é¢‘ç‡å·®å¼‚åŒ–**ï¼šä¸åŒä»»åŠ¡æ ¹æ®éœ€æ±‚è®¾ç½®ä¸åŒæ‰§è¡Œé¢‘ç‡
5. **ä¸­å¤®åè°ƒ**ï¼šä¸­å¤®æ§åˆ¶å™¨ç»Ÿä¸€ç®¡ç†å’Œç›‘æ§æ‰€æœ‰çº¿ç¨‹

### 2.5 ä»£ç å®ç°æ¡†æ¶

```python
# ä¸»çº¿ç¨‹
class MainThread:
    def __init__(self):
        self.controller = CentralController()
        
    def start(self):
        self.controller.initialize()
        self.controller.start_all_threads()
        
    def shutdown(self):
        self.controller.stop_all_threads()

# ä¸­å¤®æ§åˆ¶å™¨
class CentralController:
    def start_all_threads(self):
        # å¯åŠ¨é¡ºåºï¼šæ§åˆ¶çº¿ç¨‹ -> è§†è§‰çº¿ç¨‹ -> ä¼ æ„Ÿå™¨çº¿ç¨‹ -> UIçº¿ç¨‹
        self.control_thread.start()   # 50Hz
        self.vision_thread.start()    # 20Hz
        self.sensor_thread.start()    # 10Hz
        self.ui_thread.start()        # 5Hz
        
    def stop_all_threads(self):
        # åœæ­¢é¡ºåºï¼šUIçº¿ç¨‹ -> ä¼ æ„Ÿå™¨çº¿ç¨‹ -> è§†è§‰çº¿ç¨‹ -> æ§åˆ¶çº¿ç¨‹
        self.ui_thread.stop()
        self.sensor_thread.stop()
        self.vision_thread.stop()
        self.control_thread.stop()
```



## 3. è§†è§‰æ¨¡å—è®¾è®¡ä¸å®ç°

### 3.1 æ‘„åƒå¤´æ ‡å®š
è·å–æ‘„åƒå¤´çš„å†…å‚çŸ©é˜µå’Œç•¸å˜ç³»æ•°ï¼Œæ˜¯è¿›è¡Œç²¾ç¡®å®šä½çš„å‰æã€‚
```python
import cv2
import numpy as np

# ç¤ºä¾‹ï¼šä½¿ç”¨æ£‹ç›˜æ ¼è¿›è¡Œæ ‡å®š
def calibrate_camera(images, pattern_size=(9,6)):
    objpoints = []  # 3Dç‚¹ï¼ˆä¸–ç•Œåæ ‡ç³»ï¼‰
    imgpoints = []  # 2Dç‚¹ï¼ˆå›¾åƒåæ ‡ç³»ï¼‰
    
    # ç”Ÿæˆå¯¹è±¡ç‚¹ (0,0,0), (1,0,0), (2,0,0) ....
    objp = np.zeros((pattern_size[0]*pattern_size[1], 3), np.float32)
    objp[:,:2] = np.mgrid[0:pattern_size[0], 0:pattern_size[1]].T.reshape(-1,2)
    
    for img in images:
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        ret, corners = cv2.findChessboardCorners(gray, pattern_size, None)
        if ret:
            objpoints.append(objp)
            imgpoints.append(corners)
    
    ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)
    return mtx, dist
```

### 3.2 ç›®æ ‡è¯†åˆ«ä¸å®šä½
é‡‡ç”¨é¢œè‰²é˜ˆå€¼åˆ†å‰²ä¸è½®å»“æ£€æµ‹æ–¹æ³•ï¼Œç»“åˆPNPè§£ç®—è·å¾—ç›®æ ‡ç›¸å¯¹äºæ‘„åƒå¤´çš„ä½ç½®ã€‚
```python
def detect_and_locate(frame, camera_matrix, dist_coeffs):
    # è½¬æ¢ä¸ºHSVé¢œè‰²ç©ºé—´ï¼Œè¿›è¡Œé¢œè‰²è¿‡æ»¤
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    lower_color = np.array([25, 50, 50])  # ç¤ºä¾‹ï¼šé»„è‰²ä¸‹é™
    upper_color = np.array([35, 255, 255]) # é»„è‰²ä¸Šé™
    mask = cv2.inRange(hsv, lower_color, upper_color)
    
    # å½¢æ€å­¦æ“ä½œå»é™¤å™ªå£°
    kernel = np.ones((5,5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    
    # æŸ¥æ‰¾è½®å»“
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    if contours:
        # æ‰¾åˆ°æœ€å¤§è½®å»“
        largest_contour = max(contours, key=cv2.contourArea)
        if cv2.contourArea(largest_contour) > 500:  # é¢ç§¯é˜ˆå€¼
            # è·å–æœ€å°å¤–æ¥çŸ©å½¢
            rect = cv2.minAreaRect(largest_contour)
            box = cv2.boxPoints(rect)
            box = np.int0(box)
            
            # å·²çŸ¥ç›®æ ‡ç‰©ä½“å°ºå¯¸ï¼ˆå•ä½ï¼šç±³ï¼‰
            object_points = np.array([
                [-0.05, -0.05, 0],
                [0.05, -0.05, 0],
                [0.05, 0.05, 0],
                [-0.05, 0.05, 0]
            ], dtype=np.float32)
            
            # è§£ç®—ä½å§¿ï¼ˆå‡è®¾ç›®æ ‡åœ¨å¹³é¢Z=0ä¸Šï¼‰
            ret, rvec, tvec = cv2.solvePnP(object_points, box.astype(np.float32), 
                                          camera_matrix, dist_coeffs)
            return True, rvec, tvec, box
    return False, None, None, None
```

## 4. è¿åŠ¨æ§åˆ¶æ¨¡å—

### 4.1 ç§»åŠ¨åº•ç›˜æ§åˆ¶é€»è¾‘
é‡‡ç”¨å·®åˆ†é©±åŠ¨æ¨¡å‹ï¼Œå®ç°åŸºäºç›®æ ‡ç‚¹çš„ä½ç½®æ§åˆ¶ã€‚
```python
class MobileBaseController:
    def __init__(self, wheel_radius, wheel_base):
        self.wheel_radius = wheel_radius
        self.wheel_base = wheel_base  # ä¸¤è½®é—´è·
        
    def calculate_wheel_speeds(self, linear_x, angular_z):
        """
        æ ¹æ®çº¿é€Ÿåº¦å’Œè§’é€Ÿåº¦è®¡ç®—å·¦å³è½®è½¬é€Ÿ
        """
        left_speed = linear_x - (angular_z * self.wheel_base) / 2.0
        right_speed = linear_x + (angular_z * self.wheel_base) / 2.0
        
        # è½¬æ¢ä¸ºPWMå ç©ºæ¯”
        left_pwm = left_speed / self.wheel_radius
        right_pwm = right_speed / self.wheel_radius
        
        return left_pwm, right_pwm
    
    def navigate_to_point(self, current_pose, target_point, kp_linear=0.5, kp_angular=1.0):
        """
        ç®€å•çš„Pæ§åˆ¶å¯¼èˆªåˆ°ç›®æ ‡ç‚¹
        """
        dx = target_point[0] - current_pose[0]
        dy = target_point[1] - current_pose[1]
        distance = np.sqrt(dx**2 + dy**2)
        
        # ç›®æ ‡æœå‘è§’
        target_angle = np.arctan2(dy, dx)
        angle_error = target_angle - current_pose[2]
        
        # å½’ä¸€åŒ–è§’åº¦è¯¯å·®åˆ°[-pi, pi]
        angle_error = np.arctan2(np.sin(angle_error), np.cos(angle_error))
        
        # è®¡ç®—æ§åˆ¶é‡
        linear_speed = kp_linear * distance
        angular_speed = kp_angular * angle_error
        
        return linear_speed, angular_speed
```

### 4.2 æœºæ¢°è‡‚é€†è¿åŠ¨å­¦ä¸æ§åˆ¶
ä»¥æœºæ¢°è‡‚ä¸ºä¾‹ï¼Œå®ç°ç®€å•çš„å‡ ä½•æ³•é€†è§£ã€‚
```python
import math

class Simple6DOFIK:
    def __init__(self, link_lengths):
        self.l1, self.l2, self.l3 = link_lengths
        
    def calculate_angles(self, target_position):
        x, y, z = target_position
        
        # å…³èŠ‚1ï¼šåŸºåº§æ—‹è½¬ï¼ˆç»•Zè½´ï¼‰
        theta1 = math.atan2(y, x)
        
        # æŠ•å½±åˆ°å¹³é¢ä¸Šçš„è·ç¦»
        r = math.sqrt(x**2 + y**2) - self.l1
        d = math.sqrt(r**2 + z**2)
        
        # ä½™å¼¦å®šç†æ±‚è§£å…³èŠ‚2å’Œ3
        # è¿™é‡Œçœç•¥è¯¦ç»†æ¨å¯¼ï¼Œå®é™…éœ€æ ¹æ®æœºæ¢°è‡‚å…·ä½“ç»“æ„å®ç°
        # è¿”å›å…³èŠ‚è§’åº¦åˆ—è¡¨
        return [theta1, theta2, theta3, 0, 0, 0]  # ç¤ºä¾‹è¿”å›å€¼
```

## 5. ç³»ç»Ÿé›†æˆä¸æ§åˆ¶é€»è¾‘

### 5.1 çŠ¶æ€æœºè®¾è®¡
ä½¿ç”¨æœ‰é™çŠ¶æ€æœºç®¡ç†æœºå™¨äººçš„å·¥ä½œæµç¨‹ï¼Œç¡®ä¿ä»»åŠ¡æœ‰åºæ‰§è¡Œã€‚
```python
from enum import Enum

class RobotState(Enum):
    IDLE = 0
    SEARCHING = 1
    APPROACHING = 2
    ALIGNING = 3
    GRASPING = 4
    RETREATING = 5
    ERROR = 99

class RobotController:
    def __init__(self):
        self.state = RobotState.IDLE
        self.target_position = None
        
    def run(self):
        while True:
            if self.state == RobotState.IDLE:
                self.state = RobotState.SEARCHING
                
            elif self.state == RobotState.SEARCHING:
                # å¯»æ‰¾ç›®æ ‡
                found, rvec, tvec, _ = detect_and_locate(frame, mtx, dist)
                if found:
                    self.target_position = tvec.flatten()
                    self.state = RobotState.APPROACHING
                    
            elif self.state == RobotState.APPROACHING:
                # ç§»åŠ¨è‡³ç›®æ ‡é™„è¿‘
                distance = np.linalg.norm(self.target_position)
                if distance < 0.3:  # 30cmå†…
                    self.state = RobotState.ALIGNING
                else:
                    # å‘é€ç§»åŠ¨æŒ‡ä»¤
                    linear_speed = min(0.2, distance * 0.5)
                    # ... æ§åˆ¶åº•ç›˜ç§»åŠ¨
                    
            elif self.state == RobotState.ALIGNING:
                # ç²¾ç¡®å¯¹å‡†ç›®æ ‡
                # ... ç²¾ç¡®æ§åˆ¶é€»è¾‘
                if aligned:
                    self.state = RobotState.GRASPING
                    
            elif self.state == RobotState.GRASPING:
                # æ‰§è¡ŒæŠ“å–
                arm_angles = arm_ik.calculate_angles(self.target_position)
                # ... æ§åˆ¶æœºæ¢°è‡‚
                if grasp_success:
                    self.state = RobotState.RETREATING
                    
            # ... å…¶ä»–çŠ¶æ€å¤„ç†
            
            time.sleep(0.1)  # æ§åˆ¶å¾ªç¯é¢‘ç‡
```






### 5.2 å››è½®ç”µæœºæ§åˆ¶
```python
import smbus
import time
import struct

# è®¾ç½®I2Cæ€»çº¿å·ï¼Œé€šå¸¸ä¸º1
I2C_BUS = 1

# è®¾ç½®å››è·¯ç”µæœºé©±åŠ¨æ¨¡å—çš„I2Cåœ°å€
MOTOR_ADDR = 0x34 

# å¯„å­˜å™¨åœ°å€
ADC_BAT_ADDR = 0x00
MOTOR_TYPE_ADDR = 0x14 #ç¼–ç ç”µæœºç±»å‹è®¾ç½®
MOTOR_ENCODER_POLARITY_ADDR = 0x15 #è®¾ç½®ç¼–ç æ–¹å‘ææ€§ï¼Œ
#å¦‚æœå‘ç°ç”µæœºè½¬é€Ÿæ ¹æœ¬ä¸å—æ§åˆ¶ï¼Œè¦ä¹ˆæœ€å¿«é€Ÿåº¦è½¬åŠ¨ï¼Œè¦ä¹ˆåœæ­¢ã€‚å¯ä»¥å°†æ­¤åœ°å€çš„å€¼é‡æ–°è®¾ç½®ä¸€ä¸‹
#èŒƒå›´0æˆ–1ï¼Œé»˜è®¤0
MOTOR_FIXED_PWM_ADDR = 0x1F #å›ºå®šPWMæ§åˆ¶ï¼Œå±äºå¼€ç¯æ§åˆ¶,èŒƒå›´ï¼ˆ-100~100ï¼‰   
MOTOR_FIXED_SPEED_ADDR = 0x33 #å›ºå®šè½¬é€Ÿæ§åˆ¶ï¼Œå±äºé—­ç¯æ§åˆ¶ï¼Œ
#å•ä½ï¼šè„‰å†²æ•°æ¯10æ¯«ç§’ï¼ŒèŒƒå›´ï¼ˆæ ¹æ®å…·ä½“çš„ç¼–ç ç”µæœºæ¥ï¼Œå—ç¼–ç çº¿æ•°ï¼Œç”µå‹å¤§å°ï¼Œè´Ÿè½½å¤§å°ç­‰å½±å“ï¼Œä¸€èˆ¬åœ¨Â±50å·¦å³ï¼‰

MOTOR_ENCODER_TOTAL_ADDR = 0x3C #4ä¸ªç¼–ç ç”µæœºå„è‡ªçš„æ€»è„‰å†²å€¼
# #å¦‚æœå·²çŸ¥ç”µæœºæ¯è½¬ä¸€åœˆçš„è„‰å†²æ•°ä¸ºUï¼Œåˆå·²çŸ¥è½®å­çš„ç›´å¾„Dï¼Œé‚£ä¹ˆå°±å¯ä»¥é€šè¿‡è„‰å†²è®¡æ•°çš„æ–¹å¼å¾—çŸ¥æ¯ä¸ªè½®å­è¡Œè¿›çš„è·ç¦»
# #æ¯”å¦‚è¯»åˆ°ç”µæœº1çš„è„‰å†²æ€»æ•°ä¸ºPï¼Œé‚£ä¹ˆè¡Œè¿›çš„è·ç¦»ä¸º(P/U) * (3.14159*D)
# #å¯¹äºä¸åŒçš„ç”µæœºå¯ä»¥è‡ªè¡Œæµ‹è¯•æ¯åœˆçš„è„‰å†²æ•°Uï¼Œå¯ä»¥æ‰‹åŠ¨æ—‹è½¬10åœˆè¯»å‡ºè„‰å†²æ•°ï¼Œç„¶åå–å¹³å‡å€¼å¾—å‡º


#ç”µæœºç±»å‹å…·ä½“å€¼
MOTOR_TYPE_WITHOUT_ENCODER = 0
MOTOR_TYPE_TT = 1
MOTOR_TYPE_N20 = 2
MOTOR_TYPE_JGB37_520_12V_110RPM = 3 #ç£ç¯æ¯è½¬æ˜¯44ä¸ªè„‰å†²   å‡é€Ÿæ¯”:90  é»˜è®¤

#ç”µæœºç±»å‹åŠç¼–ç æ–¹å‘ææ€§
MotorType = MOTOR_TYPE_N20
MotorEncoderPolarity = 0

bus = smbus.SMBus(I2C_BUS)
speed1 = [20,20,20,20]
speed2 = [-20,-20,-20,-20]
speed3 = [0,0,0,0]

pwm1 = [50,50,50,50]
pwm2 = [-100,-100,-100,-100]
pwm3 = [0,0,0,0]

def Motor_Init(): #ç”µæœºåˆå§‹åŒ–
    bus.write_byte_data(MOTOR_ADDR, MOTOR_TYPE_ADDR, MotorType)  #è®¾ç½®ç”µæœºç±»å‹
    time.sleep(0.5)
    bus.write_byte_data(MOTOR_ADDR, MOTOR_ENCODER_POLARITY_ADDR, MotorEncoderPolarity)  #è®¾ç½®ç¼–ç ææ€§

def main():
    while True:
      battery = bus.read_i2c_block_data(MOTOR_ADDR, ADC_BAT_ADDR)
      print("V = {0}mV".format(battery[0]+(battery[1]<<8)))
      
      Encode = struct.unpack('iiii',bytes(bus.read_i2c_block_data(MOTOR_ADDR, MOTOR_ENCODER_TOTAL_ADDR,16)))
      
      print("Encode1 = {0}  Encode2 = {1}  Encode3 = {2}  Encode4 = {3}".format(Encode[0],Encode[1],Encode[2],Encode[3]))
      
      #PWMæ§åˆ¶ï¼ˆæ³¨æ„ï¼šPWMæ§åˆ¶æ˜¯ä¸€ä¸ªæŒç»­æ§åˆ¶çš„è¿‡ç¨‹ï¼Œè‹¥æœ‰å»¶æ—¶åˆ™ä¼šæ‰“æ–­ç”µæœºçš„è¿è¡Œï¼‰
      #bus.write_i2c_block_data(MOTOR_ADDR, MOTOR_FIXED_PWM_ADDR,pwm1)
      
      
      #å›ºå®šè½¬é€Ÿæ§åˆ¶
      bus.write_i2c_block_data(MOTOR_ADDR, MOTOR_FIXED_SPEED_ADDR,speed1)
      time.sleep(3)
      bus.write_i2c_block_data(MOTOR_ADDR, MOTOR_FIXED_SPEED_ADDR,speed2)
      time.sleep(3)
      bus.write_i2c_block_data(MOTOR_ADDR, MOTOR_FIXED_SPEED_ADDR,speed3)
      time.sleep(3)


if __name__ == "__main__":
    Motor_Init()
    main()
```

### 5.3 èˆµæœºæ§åˆ¶
```python
# USBæ‰‹æŸ„æ§åˆ¶éº¦è½®ç”µæœºå’Œèˆµæœºäº‘å°æ•´åˆç¨‹åº
# åŠŸèƒ½ï¼šå·¦æ‘‡æ†æ§åˆ¶å››ä¸ªéº¦è½®è¿åŠ¨ï¼ˆå·¦ç§»=å‘å·¦æ¼‚ç§»ã€å³ç§»=å‘å³æ¼‚ç§»ï¼‰ï¼Œå³æ‘‡æ†æ§åˆ¶æ°´å¹³/ç«–ç›´èˆµæœºï¼ŒXABYé”®æ§åˆ¶ç‰¹å®šæ–¹å‘ï¼ˆX=å·¦è½¬ã€B=å³è½¬ï¼‰
import pygame
import sys
import time
import smbus
import struct
import os  # ç”¨äºæ‰§è¡Œç³»ç»Ÿå‘½ä»¤æ£€æŸ¥åº“æ˜¯å¦å®‰è£…
from pygame.locals import *

# æ£€æŸ¥å¹¶å®‰è£…å¿…è¦çš„èˆµæœºæ§åˆ¶åº“
try:
    from adafruit_servokit import ServoKit
    import board
    import busio
except ImportError:
    print("âš ï¸ æ£€æµ‹åˆ°ç¼ºå°‘å¿…è¦çš„èˆµæœºæ§åˆ¶åº“ï¼Œæ­£åœ¨å°è¯•å®‰è£…...")
    os.system("pip3 install adafruit-circuitpython-servokit")
    os.system("pip3 install adafruit-blinka")
    from adafruit_servokit import ServoKit
    import board
    import busio

# -------------------------- 1. ç”µæœºé©±åŠ¨é…ç½®ï¼ˆI2Cæ€»çº¿ï¼‰ --------------------------
MOTOR_I2C_BUS = 1
MOTOR_ADDR = 0x34 

# ç”µæœºé©±åŠ¨å¯„å­˜å™¨åœ°å€å®šä¹‰
ADC_BAT_ADDR = 0x00                  # ç”µæ± ç”µå‹æ£€æµ‹å¯„å­˜å™¨
MOTOR_TYPE_ADDR = 0x14               # ç”µæœºç±»å‹è®¾ç½®å¯„å­˜å™¨
MOTOR_ENCODER_POLARITY_ADDR = 0x15   # ç¼–ç å™¨æ–¹å‘ææ€§å¯„å­˜å™¨
MOTOR_FIXED_SPEED_ADDR = 0x33        # å›ºå®šè½¬é€Ÿè½¬é€Ÿæ§åˆ¶å¯„å­˜å™¨
MOTOR_ENCODER_TOTAL_ADDR = 0x3C      # ç¼–ç å™¨æ€»è„‰å†²è®¡æ•°å¯„å­˜å™¨

# ç”µæœºç±»å‹å®šä¹‰
MOTOR_TYPE_WITHOUT_ENCODER = 0
MOTOR_TYPE_TT = 1
MOTOR_TYPE_N20 = 2  # N20ç¼–ç ç”µæœº
MOTOR_TYPE_JGB37_520 = 3

# ç”µæœºåˆå§‹åŒ–å‚æ•°
MotorType = MOTOR_TYPE_N20            # ä½¿ç”¨N20ç¼–ç ç”µæœº
MotorEncoderPolarity = 0              # ç¼–ç å™¨ææ€§
MAX_MOTOR_SPEED = 30                  # ç”µæœºæœ€å¤§è½¬é€Ÿ
TURN_IN_PLACE_SCALE = 1.0             # åŸåœ°è½¬å¼¯é€Ÿåº¦æ¯”ä¾‹
KEY_PRESS_SPEED = 20                  # æŒ‰é”®æ§åˆ¶æ—¶çš„å›ºå®šé€Ÿåº¦
TURN_SMOOTHING_FACTOR = 0.2           # è½¬å‘å¹³æ»‘å› å­ï¼Œå‡å°‘å¡é¡¿
motor_bus = smbus.SMBus(MOTOR_I2C_BUS)# åˆå§‹åŒ–ç”µæœºI2Cæ€»çº¿

# æ–°å¢ï¼šç”¨äºå¹³æ»‘å¤„ç†çš„å˜é‡
last_rotate = 0.0                     # ä¸Šä¸€æ¬¡çš„æ—‹è½¬åˆ†é‡


# -------------------------- 2. èˆµæœºäº‘å°é…ç½® --------------------------
SERVO_I2C_BUS = 1  # ä¸ç”µæœºç›¸åŒçš„I2Cæ€»çº¿å·
SERVO_ADDR = 0x40   # èˆµæœºé©±åŠ¨æ¿é»˜è®¤åœ°å€

# 1. æ°´å¹³èˆµæœºï¼ˆTA90Sï¼Œé€šé“0ï¼Œ360Â°è¿ç»­æ—‹è½¬ï¼‰
HORIZONTAL_CH = 0
H_STOP_MIN = 116          # åœæ­¢åŒºé—´ä¸‹é™
H_STOP_MAX = 126          # åœæ­¢åŒºé—´ä¸Šé™
H_STOP = 121              # åœæ­¢è§’åº¦ï¼ˆåŒºé—´ä¸­é—´å€¼ï¼‰
H_CW_ANGLE = 140          # é¡ºæ—¶é’ˆæ—‹è½¬è§’åº¦
H_CCW_ANGLE = 100         # é€†æ—¶é’ˆæ—‹è½¬è§’åº¦

# 2. ç«–ç›´èˆµæœºï¼ˆ180Â°è§’åº¦èˆµæœºï¼Œé€šé“1ï¼Œä¸Šä¸‹è¿åŠ¨ï¼‰
VERTICAL_CH = 1
V_MIN = 0                 # å‘ä¸Šæé™è§’åº¦
V_MAX = 180               # å‘ä¸‹æé™è§’åº¦
V_MID = 90                # ä¸­é—´ä½ç½®
V_ROCKER_STEP = 1         # æ‘‡æ†æ§åˆ¶çš„æ­¥é•¿


# -------------------------- 3. æ‰‹æŸ„é…ç½®ä¸å‚æ•° --------------------------
# è½´å®šä¹‰
AXIS_LEFT_X = 0   # å·¦æ‘‡æ†Xè½´ï¼šå·¦å³æ¼‚ç§»æ§åˆ¶ï¼ˆå·¦ç§»=å‘å·¦æ¼‚ç§»ï¼Œå³ç§»=å‘å³æ¼‚ç§»ï¼‰
AXIS_LEFT_Y = 1   # å·¦æ‘‡æ†Yè½´ï¼šå‰åç§»åŠ¨æ§åˆ¶
AXIS_RIGHT_Y = 3  # å³æ‘‡æ†Yè½´ï¼šä¸Šä¸‹æ§åˆ¶ç«–ç›´èˆµæœº
AXIS_RIGHT_X = 2  # å³æ‘‡æ†Xè½´ï¼šå·¦å³æ§åˆ¶æ°´å¹³èˆµæœº

# æŒ‰é”®å®šä¹‰ - åŠŸèƒ½æ˜ å°„ï¼ˆæŒ‰é”®æœ¬èº«å®šä¹‰ä¸å˜ï¼ŒåŠŸèƒ½è°ƒæ•´ï¼‰
X_BUTTON = 3         # Xé”®ï¼šå·¦è½¬
B_BUTTON = 1         # Bé”®ï¼šå³è½¬
Y_BUTTON = 4         # Yé”®ï¼šå‰è¿›
A_BUTTON = 0         # Aé”®ï¼šåé€€
BUTTON10 = 10        # æŒ‰é”®10ï¼šæ°´å¹³å·¦ç§»
BUTTON11 = 11        # æŒ‰é”®11ï¼šæ°´å¹³å³ç§»

# æ§åˆ¶å‚æ•°
ROCKER_THRESHOLD = 0.15   # é™ä½é˜ˆå€¼ï¼Œæé«˜çµæ•åº¦
MIXED_MOVEMENT_SCALE = 0.7 # æ··åˆè¿åŠ¨æ—¶çš„é€Ÿåº¦ç¼©æ”¾æ¯”ä¾‹ï¼Œé¿å…ç”µæœºè¿‡è½½
LAST_BUTTON_STATE = [False, False, False, False, False, False]  # è®°å½•ä¸Šä¸€æ¬¡æŒ‰é”®çŠ¶æ€ï¼ˆY/A/B/X/æŒ‰é”®10/æŒ‰é”®11ï¼‰


# -------------------------- 4. å…¨å±€å˜é‡ --------------------------
current_h_angle = H_STOP    # å½“å‰æ°´å¹³èˆµæœºè§’åº¦
current_v_angle = V_MID     # å½“å‰ç«–ç›´èˆµæœºè§’åº¦
h_rotating = False          # æ°´å¹³èˆµæœºæ˜¯å¦æ­£åœ¨æ—‹è½¬


# -------------------------- 5. ç”µæœºæ§åˆ¶å‡½æ•° --------------------------
def motor_init():
    """ç”µæœºé©±åŠ¨æ¨¡å—åˆå§‹åŒ–ï¼ˆè®¾ç½®ç”µæœºç±»å‹å’Œç¼–ç å™¨ææ€§ï¼‰"""
    motor_bus.write_byte_data(MOTOR_ADDR, MOTOR_TYPE_ADDR, MotorType)
    time.sleep(0.5)  # ç­‰å¾…è®¾ç½®ç”Ÿæ•ˆ
    motor_bus.write_byte_data(MOTOR_ADDR, MOTOR_ENCODER_POLARITY_ADDR, MotorEncoderPolarity)
    print("âœ… ç”µæœºé©±åŠ¨åˆå§‹åŒ–å®Œæˆ")


def set_motor_speed(speed1, speed2, speed3, speed4):
    """
    è®¾ç½®4ä¸ªç”µæœºçš„è½¬é€Ÿï¼ˆé—­ç¯æ§åˆ¶ï¼‰
    å‚æ•°ï¼šspeed1~speed4 åˆ†åˆ«å¯¹åº”4ä¸ªç”µæœºçš„è½¬é€Ÿï¼ˆ-MAX_MOTOR_SPEED ~ MAX_MOTOR_SPEEDï¼‰
    éº¦è½®å¸ƒå±€ï¼šM1=å³å‰è½®(Bè½®), M2=å·¦å‰è½®(Aè½®), M3=å³åè½®(Aè½®), M4=å·¦åè½®(Bè½®)
    """
    # é™åˆ¶è½¬é€ŸèŒƒå›´
    speed1 = max(-MAX_MOTOR_SPEED, min(MAX_MOTOR_SPEED, speed1))
    speed2 = max(-MAX_MOTOR_SPEED, min(MAX_MOTOR_SPEED, speed2))
    speed3 = max(-MAX_MOTOR_SPEED, min(MAX_MOTOR_SPEED, speed3))
    speed4 = max(-MAX_MOTOR_SPEED, min(MAX_MOTOR_SPEED, speed4))
    
    # è½¬æ¢ä¸ºå­—èŠ‚åˆ—è¡¨å¹¶å‘é€
    speed_list = [int(speed1), int(speed2), int(speed3), int(speed4)]
    motor_bus.write_i2c_block_data(MOTOR_ADDR, MOTOR_FIXED_SPEED_ADDR, speed_list)


def read_motor_state():
    """è¯»å–ç”µæœºçŠ¶æ€ï¼ˆç”µæ± ç”µå‹ + ç¼–ç å™¨è„‰å†²æ•°ï¼‰å¹¶æ‰“å°"""
    # è¯»å–ç”µæ± ç”µå‹
    battery = motor_bus.read_i2c_block_data(MOTOR_ADDR, ADC_BAT_ADDR)
    battery_voltage = battery[0] + (battery[1] << 8)
    
    # è¯»å–ç¼–ç å™¨æ•°æ®
    encoder_data = motor_bus.read_i2c_block_data(MOTOR_ADDR, MOTOR_ENCODER_TOTAL_ADDR, 16)
    encode1, encode2, encode3, encode4 = struct.unpack('iiii', bytes(encoder_data))
    
    # æ‰“å°çŠ¶æ€
    return f"ç”µæ± ç”µå‹ï¼š{battery_voltage}mV | ç¼–ç å™¨(M1-M4)ï¼š[{encode1}, {encode2}, {encode3}, {encode4}]"


# -------------------------- 6. èˆµæœºæ§åˆ¶å‡½æ•° --------------------------
def init_servos():
    """åˆå§‹åŒ–èˆµæœºé©±åŠ¨æ¿å’Œèˆµæœºï¼ˆä¸ç”µæœºå…±ç”¨I2Cæ€»çº¿ï¼‰"""
    try:
        # ä¸ç”µæœºä½¿ç”¨ç›¸åŒçš„I2Cæ€»çº¿ï¼ˆGPIO2=SDA, GPIO3=SCLï¼‰
        valid_ports = {
            0: (board.D1, board.D0),  # I2C0å¯¹åº”çš„å¼•è„š
            1: (board.D3, board.D2)   # I2C1å¯¹åº”çš„å¼•è„š (GPIO3=SCL, GPIO2=SDA)
        }
        
        if SERVO_I2C_BUS in valid_ports:
            scl_pin, sda_pin = valid_ports[SERVO_I2C_BUS]
            i2c = busio.I2C(scl_pin, sda_pin)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„I2Cæ€»çº¿å·: {SERVO_I2C_BUS}")
        
        # ç­‰å¾…I2Cè¿æ¥å°±ç»ª
        while not i2c.try_lock():
            pass
        
        try:
            # æ‰«æI2Cæ€»çº¿ä¸Šçš„è®¾å¤‡
            devices = i2c.scan()
            if not devices:
                print("âš ï¸ æœªåœ¨I2Cæ€»çº¿ä¸Šå‘ç°ä»»ä½•è®¾å¤‡")
            else:
                print(f"âœ… åœ¨I2Cæ€»çº¿ä¸Šå‘ç°è®¾å¤‡: {[hex(d) for d in devices]}")
                if SERVO_ADDR not in devices:
                    print(f"âš ï¸ æœªå‘ç°èˆµæœºé©±åŠ¨æ¿ï¼ˆé¢„æœŸåœ°å€: {hex(SERVO_ADDR)}ï¼‰")
                if MOTOR_ADDR not in devices:
                    print(f"âš ï¸ æœªå‘ç°ç”µæœºé©±åŠ¨æ¿ï¼ˆé¢„æœŸåœ°å€: {hex(MOTOR_ADDR)}ï¼‰")
        finally:
            i2c.unlock()
        
        kit = ServoKit(channels=16, i2c=i2c, address=SERVO_ADDR)
        print("âœ… ä½¿ç”¨adafruit_servokitåˆå§‹åŒ–èˆµæœºæˆåŠŸ")
        return kit
    
    except Exception as e:
        print(f"âŒ èˆµæœºåˆå§‹åŒ–å¤±è´¥: {str(e)}")
        print("è¯·æ£€æŸ¥ä»¥ä¸‹äº‹é¡¹ï¼š")
        print("1. ç¡®ä¿å·²æ­£ç¡®å¯ç”¨I2C1: sudo raspi-config")
        print("2. ç¡®ä¿è®¾å¤‡æ­£ç¡®è¿æ¥åˆ°I2C1 (GPIO2=SDA, GPIO3=SCL)")
        print("3. æ‰‹åŠ¨å®‰è£…å¿…è¦çš„åº“:")
        print("   pip3 install adafruit-circuitpython-servokit")
        print("   pip3 install adafruit-blinka")
        print("   pip3 install smbus2")
        sys.exit(1)


def control_horizontal(kit, action):
    """æ§åˆ¶æ°´å¹³èˆµæœºï¼šæ”¯æŒå¯åŠ¨å’Œåœæ­¢æ—‹è½¬"""
    global current_h_angle, h_rotating
    
    if action == "stop":
        if h_rotating:
            kit.servo[HORIZONTAL_CH].angle = H_STOP
            current_h_angle = H_STOP
            h_rotating = False
        
    elif action == "cw" and not h_rotating:
        h_rotating = True
        kit.servo[HORIZONTAL_CH].angle = H_CW_ANGLE
        current_h_angle = H_CW_ANGLE
                
    elif action == "ccw" and not h_rotating:
        h_rotating = True
        kit.servo[HORIZONTAL_CH].angle = H_CCW_ANGLE
        current_h_angle = H_CCW_ANGLE


def control_vertical(kit, target_angle):
    """æ§åˆ¶ç«–ç›´èˆµæœºåˆ°ç›®æ ‡è§’åº¦ï¼ˆå¸¦è§’åº¦é™åˆ¶ï¼‰"""
    global current_v_angle
    
    # é™åˆ¶è§’åº¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
    if target_angle < V_MIN:
        target_angle = V_MIN
    elif target_angle > V_MAX:
        target_angle = V_MAX
    
    # åªæœ‰è§’åº¦å˜åŒ–æ—¶æ‰å‘é€æŒ‡ä»¤
    if target_angle != current_v_angle:
        kit.servo[VERTICAL_CH].angle = target_angle
        current_v_angle = target_angle
    
    return target_angle


# -------------------------- 7. æ‰‹æŸ„æ§åˆ¶å‡½æ•° --------------------------
def init_usb_joystick():
    """åˆå§‹åŒ–USBæ‰‹æŸ„ï¼ˆæ— å¤´æ¨¡å¼ï¼Œæ— éœ€æ˜¾ç¤ºå™¨ï¼‰"""
    # è®¾ç½®SDLè™šæ‹Ÿè§†é¢‘é©±åŠ¨
    os.environ["SDL_VIDEODRIVER"] = "dummy"
    
    # åˆå§‹åŒ–pygameå’Œæ‰‹æŸ„æ¨¡å—
    pygame.init()
    pygame.joystick.init()
    
    # æ£€æµ‹æ‰‹æŸ„è¿æ¥
    joystick_count = pygame.joystick.get_count()
    if joystick_count == 0:
        print("âŒ æœªæ£€æµ‹åˆ°USBæ‰‹æŸ„ï¼Œè¯·æ£€æŸ¥è¿æ¥ï¼")
        pygame.quit()
        sys.exit(1)
    
    # åˆå§‹åŒ–ç¬¬ä¸€ä¸ªæ‰‹æŸ„
    joystick = pygame.joystick.Joystick(0)
    joystick.init()
    
    # æ‰“å°æ‰‹æŸ„ä¿¡æ¯å’ŒæŒ‰é”®æ˜ å°„ï¼Œæ–¹ä¾¿è°ƒè¯•
    print(f"âœ… å·²è¿æ¥æ‰‹æŸ„ï¼š{joystick.get_name()}")
    print(f"   æŒ‰é”®æ•°é‡ï¼š{joystick.get_numbuttons()}ï¼Œè½´æ•°é‡ï¼š{joystick.get_numaxes()}")
    print("   æŒ‰é”®æ˜ å°„ï¼š")
    print(f"   - Xé”®(ç´¢å¼•{X_BUTTON})ï¼šå·¦è½¬")
    print(f"   - Bé”®(ç´¢å¼•{B_BUTTON})ï¼šå³è½¬")
    print(f"   - Yé”®(ç´¢å¼•{Y_BUTTON})ï¼šå‰è¿›")
    print(f"   - Aé”®(ç´¢å¼•{A_BUTTON})ï¼šåé€€")
    print(f"   - æŒ‰é”®10(ç´¢å¼•{BUTTON10})ï¼šæ°´å¹³å·¦ç§»")
    print(f"   - æŒ‰é”®11(ç´¢å¼•{BUTTON11})ï¼šæ°´å¹³å³ç§»")
    
    return joystick


def handle_joystick_input(kit, joystick):
    """å¤„ç†æ‰‹æŸ„è¾“å…¥å¹¶æ§åˆ¶ç”µæœºå’Œèˆµæœº"""
    global current_v_angle, LAST_BUTTON_STATE, last_rotate
    
    # å¤„ç†pygameäº‹ä»¶
    for event in pygame.event.get():
        if event.type == JOYDEVICEREMOVED:
            print("\nâŒ æ‰‹æŸ„å·²æ–­å¼€è¿æ¥ï¼")
            pygame.quit()
            sys.exit(1)
        # æŒ‰é”®æŒ‰ä¸‹äº‹ä»¶å¤„ç†
        elif event.type == JOYBUTTONDOWN:
            if event.button == Y_BUTTON:  # Yé”®ï¼šå‰è¿›
                print("\nğŸ“Œ æŒ‰ä¸‹äº†å‰è¿›(Yé”®)")
            elif event.button == A_BUTTON:  # Aé”®ï¼šåé€€
                print("\nğŸ“Œ æŒ‰ä¸‹äº†åé€€(Aé”®)")
            elif event.button == B_BUTTON:  # Bé”®ï¼šå³è½¬
                print("\nğŸ“Œ æŒ‰ä¸‹äº†å³è½¬(Bé”®)")
            elif event.button == X_BUTTON:  # Xé”®ï¼šå·¦è½¬
                print("\nğŸ“Œ æŒ‰ä¸‹äº†å·¦è½¬(Xé”®)")
            elif event.button == BUTTON10:  # æŒ‰é”®10ï¼šæ°´å¹³å·¦ç§»
                print("\nğŸ“Œ æŒ‰ä¸‹äº†æ°´å¹³å·¦ç§»(æŒ‰é”®10)")
            elif event.button == BUTTON11:  # æŒ‰é”®11ï¼šæ°´å¹³å³ç§»
                print("\nğŸ“Œ æŒ‰ä¸‹äº†æ°´å¹³å³ç§»(æŒ‰é”®11)")
    
    # è¯»å–å·¦æ‘‡æ†æ•°æ®ï¼ˆæ§åˆ¶ç”µæœºï¼‰
    left_x = round(joystick.get_axis(AXIS_LEFT_X), 2)   # å·¦å³æ¼‚ç§»æ§åˆ¶ï¼ˆå·¦ç§»=å‘å·¦æ¼‚ç§»ï¼Œå³ç§»=å‘å³æ¼‚ç§»ï¼‰
    left_y = round(joystick.get_axis(AXIS_LEFT_Y), 2)   # å‰åç§»åŠ¨æ§åˆ¶
    
    # è°ƒè¯•ï¼šæ‰“å°å·¦æ‘‡æ†Xå€¼ï¼Œç¡®è®¤æ˜¯å¦æœ‰è¾“å…¥ï¼ˆå·¦ç§»ä¸ºè´Ÿ=å‘å·¦æ¼‚ç§»ï¼Œå³ç§»ä¸ºæ­£=å‘å³æ¼‚ç§»ï¼‰
    if abs(left_x) > ROCKER_THRESHOLD:
        print(f"\rè°ƒè¯•ï¼šå·¦æ‘‡æ†Xå€¼ = {left_x}ï¼ˆè´Ÿ=å‘å·¦æ¼‚ç§»ï¼Œæ­£=å‘å³æ¼‚ç§»ï¼‰", end="", flush=True)
    
    # è¯»å–å³æ‘‡æ†æ•°æ®ï¼ˆæ§åˆ¶èˆµæœºï¼‰
    right_y = joystick.get_axis(AXIS_RIGHT_Y)  # ç«–ç›´æ§åˆ¶
    right_x = joystick.get_axis(AXIS_RIGHT_X)  # æ°´å¹³æ§åˆ¶
    
    # è¯»å–æŒ‰é”®çŠ¶æ€ï¼ˆé¡ºåºï¼šYé”®(å‰è¿›)/Aé”®(åé€€)/Bé”®(å³è½¬)/Xé”®(å·¦è½¬)/æŒ‰é”®10(æ°´å¹³å·¦ç§»)/æŒ‰é”®11(æ°´å¹³å³ç§»)ï¼‰
    btn_states = [
        joystick.get_button(Y_BUTTON),    # Yé”®ï¼šå‰è¿›
        joystick.get_button(A_BUTTON),    # Aé”®ï¼šåé€€
        joystick.get_button(B_BUTTON),    # Bé”®ï¼šå³è½¬
        joystick.get_button(X_BUTTON),    # Xé”®ï¼šå·¦è½¬
        joystick.get_button(BUTTON10),    # æŒ‰é”®10ï¼šæ°´å¹³å·¦ç§»
        joystick.get_button(BUTTON11)     # æŒ‰é”®11ï¼šæ°´å¹³å³ç§»
    ]
    
    # æ›´æ–°æŒ‰é”®çŠ¶æ€
    for i in range(6):
        LAST_BUTTON_STATE[i] = btn_states[i]
    
    # è¿‡æ»¤å¾®å°æŠ–åŠ¨
    left_x = 0.0 if abs(left_x) < ROCKER_THRESHOLD else left_x
    left_y = 0.0 if abs(left_y) < ROCKER_THRESHOLD else left_y
    right_y = 0.0 if abs(right_y) < ROCKER_THRESHOLD else right_y
    right_x = 0.0 if abs(right_x) < ROCKER_THRESHOLD else right_x

    # -------------------------- æ§åˆ¶ç”µæœºï¼ˆéº¦è½®ç®—æ³•ï¼‰ --------------------------
    # æŒ‰é”®æ§åˆ¶ä¼˜å…ˆçº§é«˜äºæ‘‡æ†æ§åˆ¶
    if btn_states[0]:  # Yé”®ï¼šå‰è¿›
        # æ ¹æ®éº¦è½®ç±»å‹è°ƒæ•´ï¼šM1(B), M2(A), M3(A), M4(B)
        speed1 = KEY_PRESS_SPEED   # å³å‰è½®(Bè½®)
        speed2 = KEY_PRESS_SPEED   # å·¦å‰è½®(Aè½®)
        speed3 = KEY_PRESS_SPEED   # å³åè½®(Aè½®)
        speed4 = KEY_PRESS_SPEED   # å·¦åè½®(Bè½®)
    elif btn_states[1]:  # Aé”®ï¼šåé€€
        # æ‰€æœ‰ç”µæœºåè½¬
        speed1 = -KEY_PRESS_SPEED
        speed2 = -KEY_PRESS_SPEED
        speed3 = -KEY_PRESS_SPEED
        speed4 = -KEY_PRESS_SPEED
    elif btn_states[3]:  # Xé”®ï¼šå·¦è½¬
        # å·¦è½¬æ§åˆ¶é€»è¾‘ï¼ˆä¿æŒåŸä»£ç é€»è¾‘ï¼Œä»…æ›´æ–°æ³¨é‡Šï¼‰
        speed1 = KEY_PRESS_SPEED   # å³å‰è½®(Bè½®)æ­£è½¬
        speed2 = -KEY_PRESS_SPEED  # å·¦å‰è½®(Aè½®)åè½¬
        speed3 = KEY_PRESS_SPEED   # å³åè½®(Aè½®)æ­£è½¬
        speed4 = -KEY_PRESS_SPEED  # å·¦åè½®(Bè½®)åè½¬
    elif btn_states[2]:  # Bé”®ï¼šå³è½¬
        # å³è½¬æ§åˆ¶é€»è¾‘ï¼ˆä¿æŒåŸä»£ç é€»è¾‘ï¼Œä»…æ›´æ–°æ³¨é‡Šï¼‰
        speed1 = -KEY_PRESS_SPEED  # å³å‰è½®(Bè½®)åè½¬
        speed2 = KEY_PRESS_SPEED   # å·¦å‰è½®(Aè½®)æ­£è½¬
        speed3 = -KEY_PRESS_SPEED  # å³åè½®(Aè½®)åè½¬
        speed4 = KEY_PRESS_SPEED   # å·¦åè½®(Bè½®)æ­£è½¬
    elif btn_states[4]:  # æŒ‰é”®10ï¼šæ°´å¹³å·¦ç§»
        # æ¨¡æ‹Ÿæ°´å¹³å·¦ç§»ï¼Œä½¿ç”¨å›ºå®šå€¼ï¼ˆä¿æŒåŸä»£ç é€»è¾‘ï¼Œä»…æ›´æ–°æ³¨é‡Šï¼‰
        left_x = -1.0  # ç›¸å½“äºæ°´å¹³å·¦ç§»æŒ‡ä»¤
        forward_backward = -left_y  # åå‘å¤„ç†
        target_rotate = left_x
        
        # ä½¿ç”¨å¹³æ»‘è¿‡æ¸¡ç®—æ³•
        rotate = last_rotate * (1 - TURN_SMOOTHING_FACTOR) + target_rotate * TURN_SMOOTHING_FACTOR
        last_rotate = rotate
        
        is_rotating = abs(rotate) > ROCKER_THRESHOLD
        is_moving = abs(forward_backward) > ROCKER_THRESHOLD
        
        if is_rotating and not is_moving:
            # çº¯æ°´å¹³å·¦ç§»æ¨¡å¼
            speed1 = -rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE  # å³å‰è½®(Bè½®)
            speed2 = rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE   # å·¦å‰è½®(Aè½®)
            speed3 = rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE   # å³åè½®(Aè½®)
            speed4 = -rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE  # å·¦åè½®(Bè½®)
        elif is_moving and not is_rotating:
            # çº¯ç§»åŠ¨æ¨¡å¼
            speed1 = forward_backward * MAX_MOTOR_SPEED
            speed2 = forward_backward * MAX_MOTOR_SPEED
            speed3 = forward_backward * MAX_MOTOR_SPEED
            speed4 = forward_backward * MAX_MOTOR_SPEED
        else:
            # æ··åˆè¿åŠ¨æ¨¡å¼
            base_speed = forward_backward * MAX_MOTOR_SPEED * MIXED_MOVEMENT_SCALE
            rotate_speed = rotate * MAX_MOTOR_SPEED * MIXED_MOVEMENT_SCALE
            
            speed1 = base_speed - rotate_speed  # å³å‰è½®(Bè½®)
            speed2 = base_speed + rotate_speed  # å·¦å‰è½®(Aè½®)
            speed3 = base_speed + rotate_speed  # å³åè½®(Aè½®)
            speed4 = base_speed - rotate_speed  # å·¦åè½®(Bè½®)
    elif btn_states[5]:  # æŒ‰é”®11ï¼šæ°´å¹³å³ç§»
        # æ¨¡æ‹Ÿæ°´å¹³å³ç§»ï¼Œä½¿ç”¨å›ºå®šå€¼ï¼ˆä¿æŒåŸä»£ç é€»è¾‘ï¼Œä»…æ›´æ–°æ³¨é‡Šï¼‰
        left_x = 1.0  # ç›¸å½“äºæ°´å¹³å³ç§»æŒ‡ä»¤
        forward_backward = -left_y  # åå‘å¤„ç†
        target_rotate = left_x
        
        # ä½¿ç”¨å¹³æ»‘è¿‡æ¸¡ç®—æ³•
        rotate = last_rotate * (1 - TURN_SMOOTHING_FACTOR) + target_rotate * TURN_SMOOTHING_FACTOR
        last_rotate = rotate
        
        is_rotating = abs(rotate) > ROCKER_THRESHOLD
        is_moving = abs(forward_backward) > ROCKER_THRESHOLD
        
        if is_rotating and not is_moving:
            # çº¯æ°´å¹³å³ç§»æ¨¡å¼
            speed1 = -rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE  # å³å‰è½®(Bè½®)
            speed2 = rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE   # å·¦å‰è½®(Aè½®)
            speed3 = rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE   # å³åè½®(Aè½®)
            speed4 = -rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE  # å·¦åè½®(Bè½®)
        elif is_moving and not is_rotating:
            # çº¯ç§»åŠ¨æ¨¡å¼
            speed1 = forward_backward * MAX_MOTOR_SPEED
            speed2 = forward_backward * MAX_MOTOR_SPEED
            speed3 = forward_backward * MAX_MOTOR_SPEED
            speed4 = forward_backward * MAX_MOTOR_SPEED
        else:
            # æ··åˆè¿åŠ¨æ¨¡å¼
            base_speed = forward_backward * MAX_MOTOR_SPEED * MIXED_MOVEMENT_SCALE
            rotate_speed = rotate * MAX_MOTOR_SPEED * MIXED_MOVEMENT_SCALE
            
            speed1 = base_speed - rotate_speed  # å³å‰è½®(Bè½®)
            speed2 = base_speed + rotate_speed  # å·¦å‰è½®(Aè½®)
            speed3 = base_speed + rotate_speed  # å³åè½®(Aè½®)
            speed4 = base_speed - rotate_speed  # å·¦åè½®(Bè½®)
    else:
        # æ‘‡æ†æ§åˆ¶ï¼ˆæ ¹æ®éº¦è½®ç±»å‹ä¼˜åŒ–ï¼‰
        # éº¦è½®å¸ƒå±€ï¼šM1=å³å‰è½®(Bè½®), M2=å·¦å‰è½®(Aè½®), M3=å³åè½®(Aè½®), M4=å·¦åè½®(Bè½®)
        
        # å‰è¿›/åé€€ (Yè½´)
        forward_backward = -left_y  # åå‘å¤„ç†
        
        # å·¦å³æ¼‚ç§» (Xè½´)ï¼šå·¦ç§»=å‘å·¦æ¼‚ç§»ï¼Œå³ç§»=å‘å³æ¼‚ç§»
        strafe = left_x
        
        # æ—‹è½¬åˆ†é‡ï¼ˆåŒ¹é…éœ€æ±‚ï¼šå·¦æ‘‡æ†å³ç§»â†’å³è½¬ï¼Œå·¦ç§»â†’å·¦è½¬ï¼‰
        rotate = -left_x * 1.2  # è´Ÿå·ç”¨äºä¿®æ­£æ—‹è½¬æ–¹å‘
        
        # åŸåœ°æ—‹è½¬æ¨¡å¼
        if abs(forward_backward) < ROCKER_THRESHOLD and abs(strafe) < ROCKER_THRESHOLD and abs(left_x) > ROCKER_THRESHOLD:
            # çº¯æ—‹è½¬æ¨¡å¼ - å·¦æ‘‡æ†å‘å³â†’å³è½¬ï¼Œå‘å·¦â†’å·¦è½¬
            speed1 = -rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE  # Bè½®
            speed2 = rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE   # Aè½®
            speed3 = rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE   # Aè½®
            speed4 = -rotate * MAX_MOTOR_SPEED * TURN_IN_PLACE_SCALE  # Bè½®
        else:
            # æ··åˆè¿åŠ¨æ¨¡å¼ - æ”¯æŒæ¼‚ç§»+ç§»åŠ¨ç»„åˆ
            speed1 = forward_backward * MAX_MOTOR_SPEED - strafe * MAX_MOTOR_SPEED - rotate * MAX_MOTOR_SPEED  # Bè½®
            speed2 = forward_backward * MAX_MOTOR_SPEED + strafe * MAX_MOTOR_SPEED + rotate * MAX_MOTOR_SPEED  # Aè½®
            speed3 = forward_backward * MAX_MOTOR_SPEED - strafe * MAX_MOTOR_SPEED + rotate * MAX_MOTOR_SPEED  # Aè½®
            speed4 = forward_backward * MAX_MOTOR_SPEED + strafe * MAX_MOTOR_SPEED - rotate * MAX_MOTOR_SPEED  # Bè½®
    
    set_motor_speed(speed1, speed2, speed3, speed4)

    # -------------------------- å³æ‘‡æ†æ§åˆ¶èˆµæœº --------------------------
    # å³æ‘‡æ†Yè½´æ§åˆ¶ï¼ˆç«–ç›´èˆµæœºï¼‰
    if right_y != 0:
        new_angle = current_v_angle + (-right_y * V_ROCKER_STEP)
        control_vertical(kit, int(new_angle))
    
    # å³æ‘‡æ†Xè½´æ§åˆ¶ï¼ˆæ°´å¹³èˆµæœºï¼‰
    if right_x != 0:
        if right_x > 0:  # æ‘‡æ†å‘å³
            control_horizontal(kit, "ccw")
        else:  # æ‘‡æ†å‘å·¦
            control_horizontal(kit, "cw")
    else:
        # æ‘‡æ†å›ä¸­ï¼šåœæ­¢æ°´å¹³æ—‹è½¬
        control_horizontal(kit, "stop")


# -------------------------- 8. ä¸»ç¨‹åº --------------------------
def main():
    print("=" * 80)
    print("ğŸ® æ‰‹æŸ„æ§åˆ¶éº¦è½®ç”µæœºå’Œèˆµæœºäº‘å°ç³»ç»Ÿ")
    print("=" * 80)
    print("éº¦è½®é…ç½®ï¼šM1=å³å‰è½®(Bè½®), M2=å·¦å‰è½®(Aè½®), M3=å³åè½®(Aè½®), M4=å·¦åè½®(Bè½®)")
    print("æ§åˆ¶è¯´æ˜ï¼š")
    print("  å·¦æ‘‡æ†æ§åˆ¶ç”µæœºï¼š")
    print("    - å‘å‰ï¼šæœºå™¨äººå‰è¿›")
    print("    - å‘åï¼šæœºå™¨äººåé€€")
    print("    - å‘å·¦ï¼šæœºå™¨äººå‘å·¦æ¼‚ç§»")
    print("    - å‘å³ï¼šæœºå™¨äººå‘å³æ¼‚ç§»")
    print("    - å‰å·¦/å‰å³ï¼šå‰è¿›å¹¶åŒæ—¶æ¼‚ç§»")
    print("    - åå·¦/åå³ï¼šåé€€å¹¶åŒæ—¶æ¼‚ç§»")
    print("  æŒ‰é”®æ§åˆ¶ï¼š")
    print(f"    - Xé”®(ç´¢å¼•{X_BUTTON})ï¼šå·¦è½¬ï¼ˆåŸåœ°æ—‹è½¬ï¼‰")
    print(f"    - Bé”®(ç´¢å¼•{B_BUTTON})ï¼šå³è½¬ï¼ˆåŸåœ°æ—‹è½¬ï¼‰")
    print(f"    - Yé”®(ç´¢å¼•{Y_BUTTON})ï¼šå‰è¿›")
    print(f"    - Aé”®(ç´¢å¼•{A_BUTTON})ï¼šåé€€")
    print(f"    - æŒ‰é”®10(ç´¢å¼•{BUTTON10})ï¼šæ°´å¹³å·¦ç§»ï¼ˆæ¨ªå‘ç§»åŠ¨ï¼‰")
    print(f"    - æŒ‰é”®11(ç´¢å¼•{BUTTON11})ï¼šæ°´å¹³å³ç§»ï¼ˆæ¨ªå‘ç§»åŠ¨ï¼‰")
    print("  å³æ‘‡æ†æ§åˆ¶äº‘å°ï¼š")
    print("    - å‘ä¸Šï¼šç«–ç›´äº‘å°ä¸Šç§»")
    print("    - å‘ä¸‹ï¼šç«–ç›´äº‘å°ä¸‹ç§»")
    print("    - å‘å·¦ï¼šæ°´å¹³äº‘å°é€†æ—¶é’ˆæ—‹è½¬")
    print("    - å‘å³ï¼šæ°´å¹³äº‘å°é¡ºæ—¶é’ˆæ—‹è½¬")
    print("=" * 80)
    print("æŒ‰Ctrl+Cé€€å‡ºç¨‹åº")
    print("=" * 80)
    
    try:
        # åˆå§‹åŒ–ç¡¬ä»¶
        motor_init()
        servo_kit = init_servos()
        joystick = init_usb_joystick()
        
        # ä¸»æ§åˆ¶å¾ªç¯
        while True:
            # å¤„ç†æ‰‹æŸ„è¾“å…¥å¹¶æ§åˆ¶è®¾å¤‡
            handle_joystick_input(servo_kit, joystick)
            
            # è¯»å–å¹¶æ‰“å°ç”µæœºçŠ¶æ€
            motor_status = read_motor_state()
            print(f"\rğŸ“Š {motor_status} | èˆµæœºçŠ¶æ€ï¼šæ°´å¹³={current_h_angle}, ç«–ç›´={current_v_angle}", end="", flush=True)
            
            # æ§åˆ¶å¾ªç¯é¢‘ç‡
            time.sleep(0.05)
    
    except KeyboardInterrupt:
        print("\n\nğŸ“¤ ç¨‹åºé€€å‡ºä¸­...")
    except Exception as e:
        print(f"\nâŒ ç¨‹åºè¿è¡Œå‡ºé”™: {str(e)}")
    finally:
        # ç¨‹åºç»“æŸæ—¶å¤ä½æ‰€æœ‰è®¾å¤‡
        if 'motor_bus' in locals():
            set_motor_speed(0, 0, 0, 0)
            motor_bus.close()
            print("âœ… ç”µæœºå·²åœæ­¢å¹¶é‡Šæ”¾èµ„æº")
        
        if 'servo_kit' in locals():
            servo_kit.servo[HORIZONTAL_CH].angle = H_STOP
            servo_kit.servo[VERTICAL_CH].angle = V_MID
            print("âœ… èˆµæœºå·²å¤ä½åˆ°åˆå§‹ä½ç½®")
        
        # æ¸…ç†æ‰‹æŸ„èµ„æº
        if 'joystick' in locals():
            joystick.quit()
        pygame.joystick.quit()
        pygame.quit()

if __name__ == "__main__":
    main()
```
### 5.4 é€šä¿¡æ¶æ„
- **å†…éƒ¨é€šä¿¡**: ä½¿ç”¨Python multiprocessingæˆ–ROS 2è¯é¢˜/æœåŠ¡è¿›è¡Œæ¨¡å—é—´æ•°æ®äº¤æ¢
- **ç¡¬ä»¶é€šä¿¡**: 
  

## 6. ç³»ç»Ÿæµ‹è¯•ä¸ä¼˜åŒ–

### 6.1 æµ‹è¯•é¡¹ç›®


### 6.2 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ




---
